{
    "modelData": {
        "fileType": "Palette",
        "repoService": "GitHub",
        "repoBranch": "master",
        "repo": "ICRAR/EAGLE_test_repo",
        "filePath": "EAGLE-959/markdown-test.palette",
        "eagleVersion": "Unknown",
        "eagleCommitHash": "Unknown",
        "schemaVersion": "",
        "readonly": true,
        "repositoryUrl": "",
        "commitHash": "",
        "downloadUrl": "",
        "signature": "",
        "lastModifiedName": "",
        "lastModifiedEmail": "",
        "lastModifiedDatetime": 0,
        "numLGNodes": 2
    },
    "nodeDataArray": [
        {
            "category": "PythonApp",
            "categoryType": "Application",
            "key": -1,
            "text": "TestA",
            "description": "A DROP that points to data stored in a mounted filesystem.\r\n\r\nUsers can (but usually don't need to) specify both a `filepath` and a\r\n`dirname` parameter for each FileDrop. The combination of these two parameters\r\nwill determine the final location of the file backed up by this drop on the\r\nunderlying filesystem. When no ``filepath`` is provided, the drop's UID will be\r\nused as a filename. When a relative filepath is provided, it is relative to\r\n``dirname``. When an absolute ``filepath`` is given, it is used as-is.\r\nWhen a relative ``dirname`` is provided, it is relative to the base directory\r\nof the currently running session (i.e., a directory with the session ID as a\r\nname, placed within the currently working directory of the Node Manager\r\nhosting that session). If ``dirname`` is absolute, it is used as-is.\r\n\r\nIn some cases drops are created **outside** the context of a session, most\r\nnotably during unit tests. In these cases the base directory is a fixed\r\nlocation under ``/tmp``.\r\n\r\nThe following table summarizes the calculation of the final path used by\r\nthe ``FileDrop`` class depending on its parameters:\r\n\r\n\r\n|             |              |                     | filename            |              |\r\n|-------------|--------------|---------------------|---------------------|--------------|\r\n|             |              | **empty**           | **relative**        | **absolute** |\r\n|             | **empty**    |/``$B``/``$u``       |/``$B``/``$f``       |/``$f``       |\r\n| **dirname** | **relative** |/``$B``/``$d``/``$u``|/``$B``/``$d``/``$f``|**ERROR**     |\r\n|             | **absolute** |/``$d``/``$u``       |/``$d``/``$f``       |**ERROR**     |\r\n\r\nIn the table, ``$f`` is the value of ``filepath``, ``$d`` is the value of\r\n``dirname``, ``$u`` is the drop's UID and ``$B`` is the base directory for\r\nthis drop's session, namely ``/the/cwd/$session_id``.",
            "repositoryUrl": "",
            "commitHash": "",
            "paletteDownloadUrl": "",
            "dataHash": "",
            "inputPorts": [],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "fields": [],
            "applicationArgs": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        },
        {
            "category": "PythonApp",
            "categoryType": "Application",
            "key": -2,
            "text": "TestB",
            "description": "A BarrierAppDROP that represents a process running in a container\r\nhosted by a local docker daemon. Depending on the host system, the docker\r\ndaemon might be automatically activated when a client tries to connect to\r\nit via its unix socket (like with systemd) or it needs to be brought up\r\nprior to any client operation (upstart). In any case, if the daemon is\r\nnot present, this class will raise exceptions whenever it tries to connect\r\nto the server to perform some operation.\r\n\r\nDocker containers are built from docker images, which are pulled to the host\r\nwhere the docker daemon runs either explicitly (via `docker pull`) or less\r\nvisibly (e.g., when running `docker run` using an image that has not been\r\nfetched yet). This DockerApp application will explicitly pull the image at\r\n`initialize` time, meaning that the docker images will become available at\r\nthe time the physical graph (which this application is part of) is deployed.\r\nDocker containers also need a command to be run in them, which should be\r\nan available program inside the image. Optionally, users can provide a\r\nworking directory (in the container) under which the command will run\r\nvia the `workingDir` parameter.\r\n\r\n**Input and output**\r\n\r\nThe inputs and outputs used by the dockerized application are made available\r\nby mapping host directories and files as \"data volumes\". Inputs are bound\r\nusing their full path, but outputs are bound only up to their dirnames,\r\nbecause otherwise they would be created at container creation time by\r\nDocker. For example, the output /a/b/c will produce a binding to /dlg/a/b\r\ninside the docker container, where c will have to be written by the process\r\nrunning in the container.\r\n\r\nSince the command to be run in the container receives most probably as\r\narguments the paths of its inputs and outputs, and since these might not be\r\nknown precisely until runtime, users should use placeholders for them in the\r\ncommand-line specification. Placeholders for input locations take the form\r\nof \"%iX\", where X starts from 0 and refers to the X-th filesystem-related\r\ninput. Likewise, output locations are specified as \"%oX\". Alternatively,\r\ninputs and outputs can be referred to by their UIDs, in which case the\r\nplaceholders will look like \"%i[X]\" and \"%o[X]\" respectively, where X is the\r\nUID of the input/output being referenced.\r\n\r\nData volumes are a file-specific feature. For this reason, volumes are setup\r\nfor file-system based input/output DROPs only, namely the FileDROP and the\r\nDirectoryContainer types. Other DROP types can instead pass down their\r\ndataURL property via the command-line by using placeholders. Placeholders\r\nfor input DROP dataURLs take the form of \"%iDataURLX\", where X starts from 0\r\nand refers to the X-th non-filesystem related input. Likewise, output\r\ndataURLs are specified as \"%oDataURLX\". Alternatively users can refer to the\r\ndataURL of a specific input or output as \"%iDataURL[X]\" and \"%oDataURL[X]\"\r\nrespectively, where X is the UID of the input/output being referenced.\r\n\r\nAdditional volume bindings can be specified via the keyword arguments when\r\ncreating the DockerApp. The host file/directories must exist at the moment\r\nof creating the DockerApp; otherwise it will fail to initialize.\r\n\r\n**Users**\r\n\r\nA docker container usually runs as root by default. One of the major\r\ndrawbacks of this is that the output generated by the containerized\r\napplication will belong also to the root user of the host system, and not to\r\nthe user running the DALiuGE framework. This DockerApp avoids to run containers\r\nas the root user because of this reason. Two parameters, given at\r\nconstruction time, control this behavior:\r\n\r\n* `user`\r\n          If given indicates the user used to run the container. It is\r\n          assumed that if a user is indicated, the user already exists in\r\n          the docker image; otherwise the container will actually fail to\r\n          start. Its default value is `None`, meaning that the container\r\n          will run as the root user.\r\n* `ensureUserAndSwitch`\r\n          If the container is run as the root user, this\r\n          option indicates whether a non-root user with the same UID of the\r\n          user running this process should be: a) searched for, b) created\r\n          if it doesn't exist, and c) used to run the command inside the\r\n          container. This is achieved by prepending some shell commands to\r\n          the initial user-specified command, which will run as root first,\r\n          but that finally perform the switch within the container process.\r\n          Its default value is `True` if `user` is `None`; `False`\r\n          otherwise.\r\n\r\nUsing these two options one can thus control the user that will run the\r\ncommand inside the container.\r\n\r\n**Communication between containers**\r\n\r\nAlthough some containerized applications might run on their own, there are\r\ncases where applications need to talk to each other in order to advance\r\n(like in the case of client-server applications, or in the case of MPI\r\napplications). All containers started in the same host (and therefore, all\r\napplications running in them) belong by default to the same network, and\r\ntherefore are already visible.\r\n\r\nApplications needing to communicate with other applications should be able\r\nto specify the target's IP in their command-line. Since the IP is not known\r\nuntil containers are created, this specification is done using the\r\n%containerIp[oid]% placeholder, with 'oid' being the OID of the target\r\nDockerApp.\r\n\r\nThis need to know other DockerApp's IP imposes a sequential order on the\r\nstartup of the containers, since one needs to be started in order to learn\r\nits IP, which is used to start the second. This is handled gracefully by\r\nthe DockerApp code, with the condition that `self.handleInterest` is invoked\r\nwhere necessary. See `self.handleInterest` for more information about this\r\nmechanism.\r\n\r\n**TODO**\r\n\r\nProcesses in containers might not always exit by themselves, and the\r\ncontainers might need to be manually stopped. This the case for example of\r\nan set of MPI processes, where the master container will run the MPI\r\nprogram and the slave containers will run an SSH daemon, where the SSH\r\ndaemon will not quit automatically once the master process has ended.\r\n\r\nStill, we probably will need to differentiate between a forced quit because\r\nof a timeout, and a good quit, and therefore we might impose that processes\r\nrunning in a container must quit themselves after successfully performing\r\ntheir task.",
            "repositoryUrl": "",
            "commitHash": "",
            "paletteDownloadUrl": "",
            "dataHash": "",
            "inputPorts": [],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "fields": [],
            "applicationArgs": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "inputApplicationName": "",
            "inputApplicationType": "None",
            "inputApplicationKey": null,
            "inputApplicationDescription": "",
            "outputApplicationName": "",
            "outputApplicationType": "None",
            "outputApplicationKey": null,
            "outputApplicationDescription": ""
        }
    ],
    "linkDataArray": []
}