{
    "modelData": {
        "fileType": "palette",
        "repoService": "GitHub",
        "repoBranch": "master",
        "repo": "ICRAR/EAGLE_test_repo",
        "readonly": true,
        "filePath": "jacal-yan-843-distributed-facets.palette",
        "sha": "7b8ec29",
        "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git"
    },
    "nodeDataArray": [
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -1,
            "text": "CalcNE",
            "description": "Calculates the Normal Equations\nThis class encorporates all of the tasks needed to form imaging Normal Equations: read from a measurement set; degrid model visibilities; subtract model visibilities; grid residual visibilities and FFT the grid",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "43684be1-4fd5-4b13-ba50-8559e0826a6c",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " ParameterSet descriptor for the image solver"
                },
                {
                    "Id": "4041d723-2e8d-4e20-97a0-a2ee7c7aaecd",
                    "IdText": "Model",
                    "text": "Model",
                    "event": false,
                    "type": "scimathParams",
                    "description": " Params of solved normal equations"
                }
            ],
            "outputPorts": [
                {
                    "Id": "1e65a13f-e6bb-4392-9621-25f8b9ee94cd",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL librarc",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=CalcNE",
                    "default": "name=CalcNE",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -2,
            "text": "InitSpectralCube",
            "description": "Build the output image cube\nThis class builds the output cube in the format specified by the parset.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "b55ae366-2105-4f5e-a95c-bdb2e5b46cb9",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file"
                }
            ],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=InitSpectralCube",
                    "default": "name=InitSpectralCube",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -3,
            "text": "LoadNE",
            "description": "Example class that simply loads Normal Equations from a drop\nImplements a test method that uses the contents of the the parset to load in a measurement set and print a summary of its contents. We will simply load in a NormalEquation from a daliuge drop and output the image. This simply tests the NE interface to the daliuge memory drop.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "1670e398-4e0a-48e3-83c1-82df60fb1580",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=LoadNE",
                    "default": "name=LoadNE",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -4,
            "text": "LoadParset",
            "description": "Load a LOFAR Parameter Set in the DaliugeApplication Framework\nLoads a configuration from a file drop and generates a LOFAR::ParameterSet The first ASKAP example in the Daliuge framework that actually performs an ASKAP related task. We load a parset into memory from either a file or another Daliuge drop_status",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "dea70c27-a5a0-4863-a365-6aba831e6382",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " ParameterSet descriptor for the image solver"
                }
            ],
            "outputPorts": [
                {
                    "Id": "e4ce1292-6800-4cd6-8cd3-21b72cdaa06d",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": ""
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=LoadParset",
                    "default": "name=LoadParset",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -5,
            "text": "LoadVis",
            "description": "Loads a visibility set, grids it onto the UV plane and FFTs the grid\nLoads a configuration from a file drop and a visibility set from a casacore::Measurement Set",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "f9c5f1da-6b53-41a3-9535-b347396d3e3b",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file Params of solved normal equations"
                }
            ],
            "outputPorts": [
                {
                    "Id": "ca041179-6b28-4e06-a5b6-058efcbef938",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=LoadVis",
                    "default": "name=LoadVis",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -6,
            "text": "MajorCycle",
            "description": "Loads a visibility set, grids it onto the UV plane and FFTs the grid\nLoads a configuration from a file drop and a visibility set from a casacore::Measurement Set",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "f45ef6fd-19e9-4115-b31e-914508e28f70",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file"
                },
                {
                    "Id": "09971e96-a220-47d2-85bd-f2adfcd1d3e0",
                    "IdText": "Cube",
                    "text": "Cube",
                    "event": false,
                    "type": "Cube",
                    "description": "Cube"
                }
            ],
            "outputPorts": [
                {
                    "Id": "c2e7d955-f7ef-4ba0-b194-80129baa458f",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=MajorCycle",
                    "default": "name=MajorCycle",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -7,
            "text": "NESpectralCube",
            "description": "Build an output image cube from input NormalEquations\nThis class builds the output cube is whatever format specified by the parset. Generates a cube of NormalEquation slices.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "0853c67d-af27-4cb3-8738-0280f0b17942",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " ParameterSet descriptor for the image solver"
                },
                {
                    "Id": "a35450d3-9c2b-4b64-a35f-6e969660acd5",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=NESpectralCube",
                    "default": "name=NESpectralCube",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -8,
            "text": "OutputParams",
            "description": "Solves an Normal Equation provided by a Daliuge Drop. Outputs the Params class as images.\nImplements an ASKAPSoft solver. This essentially takes a NormalEquation and generates a a set of \"params\" usually via a minor cycle deconvolution. We will simply load in a NormalEquation from a daliuge drop and solve it via a minor cycle deconvolution. This drop actually generates the output images based upon the contents of the Params object.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "0590a70c-65bb-4d99-b0ac-fe89816c9cb8",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " ParameterSet descriptor for the image solver"
                },
                {
                    "Id": "65bc7846-aa06-4f66-b01a-4dfdf7ef83ed",
                    "IdText": "Model",
                    "text": "Model",
                    "event": false,
                    "type": "scimathParams",
                    "description": ""
                },
                {
                    "Id": "f6bd20ed-200f-4ccd-a751-c4199ef6c3ce",
                    "IdText": "Restored Model",
                    "text": "Restored Model",
                    "event": false,
                    "type": "scimathParams",
                    "description": ""
                }
            ],
            "outputPorts": [],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=OutputParams",
                    "default": "name=OutputParams",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -9,
            "text": "ReduceNE",
            "description": "Merge two Normal Equation objects\nUse askap::scimath::ImagingNormalEquations::merge() to merge two NEs",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "9f11f909-bd56-40e6-ba89-624d39c01a55",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file ImagingNormalEquations to merge"
                },
                {
                    "Id": "534c6379-1f25-46d2-97b0-7e7366472ea7",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to merge"
                }
            ],
            "outputPorts": [
                {
                    "Id": "b0cf98cb-b4df-4028-a69a-b6617473632f",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " Merged ImagingNormalEquations to merged further or solve"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=ReduceNE",
                    "default": "name=ReduceNE",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -10,
            "text": "RestoreSolver",
            "description": "Implements an ASKAPSoft Restore solver. This essentially takes a NormalEquation and a set of \"params\" and creates a restored image.\nThis takes a configuration and a set of normal equations and uses the Solver requested in in the ParameterSet to produce an ouput model.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "5d423a83-1583-4176-8347-e0392fa0b6d0",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file Params of solved normal equations"
                },
                {
                    "Id": "a14d4360-4681-445f-b68b-ce57c6ebfc1e",
                    "IdText": "Normal",
                    "text": "Normal",
                    "event": false,
                    "type": "scimathImagingNormalEquations",
                    "description": " ImagingNormalEquations to solve"
                }
            ],
            "outputPorts": [
                {
                    "Id": "f0e0048f-5edc-4576-9c0b-8935e985ae14",
                    "IdText": "Restored Model",
                    "text": "Restored Model",
                    "event": false,
                    "type": "scimathParams",
                    "description": ""
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=RestoreSolver",
                    "default": "name=RestoreSolver",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -11,
            "text": "SolveNE",
            "description": "Implements an ASKAPSoft solver. This essentially takes a NormalEquation and generates a set of params usually via a minor cycle deconvolution.\nThis takes a configuration and a set of normal equations and uses the Solver requested in in the ParameterSet to produce an ouput model.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "ac3d1af5-98fa-4aa0-8032-f12c93fb73b0",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file ImagingNormalEquations to solve"
                }
            ],
            "outputPorts": [
                {
                    "Id": "55e0bd6f-d6d0-4c39-bd11-a8f34d4ed980",
                    "IdText": "Model",
                    "text": "Model",
                    "event": false,
                    "type": "scimathParams",
                    "description": " Params of solved normal equations"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=SolveNE",
                    "default": "name=SolveNE",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "DynlibApp",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -12,
            "text": "SpectralCube",
            "description": "Build the output image cube\nThis class builds the output cube is whatever format specified by the parset.",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [
                {
                    "Id": "683abf49-0bba-4840-be52-1cf698e12636",
                    "IdText": "Config",
                    "text": "Config",
                    "event": false,
                    "type": "LOFARParameterSet",
                    "description": " The Config file Params of solved normal equations"
                }
            ],
            "outputPorts": [
                {
                    "Id": "2623cd74-97d6-47b8-8b2d-4aba7c98a2f6",
                    "IdText": "Cube",
                    "text": "Cube",
                    "event": false,
                    "type": "Cube",
                    "description": ""
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Execution time",
                    "name": "execution_time",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated execution time",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Num CPUs",
                    "name": "num_cpus",
                    "value": 1,
                    "default": 1,
                    "description": "Number of cores used",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group start",
                    "name": "group_start",
                    "value": "false",
                    "default": "false",
                    "description": "Component is start of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Library path",
                    "name": "libpath",
                    "value": "",
                    "default": "",
                    "description": "",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Library Path",
                    "name": "libpath",
                    "value": "%JACAL_SO%",
                    "default": "%JACAL_SO%",
                    "description": "The path to the JACAL library",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Arg01",
                    "name": "Arg01",
                    "value": "name=SpectralCube",
                    "default": "name=SpectralCube",
                    "description": "",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        },
        {
            "category": "ParameterSet",
            "tag": "",
            "isData": false,
            "isGroup": false,
            "canHaveInputs": true,
            "canHaveOutputs": true,
            "drawOrderHint": 0,
            "key": -13,
            "text": "YandaParset",
            "description": "A first cut at a complete parameter set template",
            "collapsed": false,
            "showPorts": false,
            "streaming": false,
            "subject": null,
            "selected": false,
            "expanded": false,
            "inputApplicationName": "",
            "outputApplicationName": "",
            "exitApplicationName": "",
            "inputApplicationType": "None",
            "outputApplicationType": "None",
            "exitApplicationType": "None",
            "inputPorts": [],
            "outputPorts": [
                {
                    "Id": "00f7c2e8-ea56-4206-990d-c52fd8d701f7",
                    "IdText": "Config",
                    "text": "ConfigFile",
                    "event": false,
                    "type": "File",
                    "description": "The output configuration file"
                }
            ],
            "inputLocalPorts": [],
            "outputLocalPorts": [],
            "inputAppFields": [],
            "outputAppFields": [],
            "fields": [
                {
                    "text": "Data volume",
                    "name": "data_volume",
                    "value": 5,
                    "default": 5,
                    "description": "Estimated size of the data contained in this node",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Group end",
                    "name": "group_end",
                    "value": "false",
                    "default": "false",
                    "description": "Component is end of a group",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "applicationArgs": [
                {
                    "text": "Parset mode",
                    "name": "mode",
                    "value": "YANDA",
                    "default": "YANDA",
                    "description": "To what standard DALiuGE should filter and serialize the parameters.",
                    "readonly": true,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ConfigData",
                    "name": "config_data",
                    "value": "",
                    "default": "",
                    "description": "Additional configuration information to be mixed in with the initial data",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess",
                    "name": "calibaccess",
                    "value": "parset",
                    "default": "parset",
                    "description": "The type of calibration solution source. Only \"parset\" and \"table\" are currently implemented",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess.parset",
                    "name": "calibaccess.parset",
                    "value": "result.dat",
                    "default": "result.dat",
                    "description": "Parset file name where the calibration solution is stored. This parameter is meaningful only if",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess.table",
                    "name": "calibaccess.table",
                    "value": "calibdata.tab",
                    "default": "calibdata.tab",
                    "description": "The name of the casa table to be read or created.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess.table.reuse",
                    "name": "calibaccess.table.reuse",
                    "value": "false",
                    "default": "false",
                    "description": "Unless this flag is true, an old table or file, which name is given by",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess.table.maxant",
                    "name": "calibaccess.table.maxant",
                    "value": "36",
                    "default": "36",
                    "description": "Maximum number of antennas allowed (this parameter is required only if writing of the new calibration solutions is requested)",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibaccess.table.maxbeam",
                    "name": "calibaccess.table.maxbeam",
                    "value": "30",
                    "default": "30",
                    "description": "Maximum number of beams allowed (this parameter is required only if writing of the new calibration solutions is requested)",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver",
                    "name": "solver",
                    "value": "SVD",
                    "default": "SVD",
                    "description": "Selection of solver. Either \"SVD\" or \"LSQR\".",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.rmin",
                    "name": "solver.LSQR.rmin",
                    "value": "1.e-13",
                    "default": "1.e-13",
                    "description": "Minimum relative residual stopping criterion.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.niter",
                    "name": "solver.LSQR.niter",
                    "value": "100",
                    "default": "100",
                    "description": "Maximum number of minor cycles. This stopping criterion is used when minimum relative residual stopping criterion could not be reached within the specified number of solver iterations. In practice 10-15 iterations are often sufficient.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.alpha",
                    "name": "solver.LSQR.alpha",
                    "value": "0.01",
                    "default": "0.01",
                    "description": "The damping on the solution perturbation (that is performed at every major cycle). Nonzero damping values help dealing with rank deficient systems. Testing has shown the default works fine for gain or bandpass alone, but that values of 1e5 to 3e6 are often needed when solving for leakages alone or combined with gains or bandpass. For data with a fair amount of flagging use 3e5 to 1e6 and solve leakages combined with gains or bandpass to get agreement with SVD results.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.alpha_leak",
                    "name": "solver.LSQR.alpha_leak",
                    "value": "alpha",
                    "default": "alpha",
                    "description": "The same type of damping as alpha, but applied to leakages only. When it is defined explicitly then alpha is used for gains, and alpha_leak for leakages.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.verbose",
                    "name": "solver.LSQR.verbose",
                    "value": "false",
                    "default": "false",
                    "description": "The value of \"true\" enables lots of output.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.parallelMatrix",
                    "name": "solver.LSQR.parallelMatrix",
                    "value": "false",
                    "default": "false",
                    "description": "Enables mode where all frequency channels are solved together, and therefore can be coupled via frequency-dependant constraints (e.g. smoothness). The columns of the (block-diagonal) matrix, and the bandpass solution are split between different ranks. This option is only supported in ccalibrator, and must be accompanied by the following options:",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing",
                    "name": "solver.LSQR.smoothing",
                    "value": "false",
                    "default": "false",
                    "description": "Enables smoothing constraints along frequency channels. This allows obtaining smoother gain phase and amplitude. Must be used together with",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.normalizeColumns",
                    "name": "solver.LSQR.normalizeColumns",
                    "value": "false",
                    "default": "false",
                    "description": "Precondition the matrix by normalizing the columns. The solution is then sought in the scaled variables.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.type",
                    "name": "solver.LSQR.smoothing.type",
                    "value": "2",
                    "default": "2",
                    "description": "Type of smoothing gradient operator: 0-forward diff, 1-central diff, 2-Laplacian, 4-Bilaplacian.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.variableType",
                    "name": "solver.LSQR.smoothing.variableType",
                    "value": "0",
                    "default": "0",
                    "description": "imag gain parts, 1-gain magnitude, 2-gain phase, 3-magnitude and phase.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [
                        "Type of smoothing variable: 0-real"
                    ],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.accuracy",
                    "name": "solver.LSQR.smoothing.accuracy",
                    "value": "2",
                    "default": "2",
                    "description": "Finite difference accuracy order. Support 2, 4, and 6.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.minWeight",
                    "name": "solver.LSQR.smoothing.minWeight",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "Starting smoothing weight (at the first major cycle).",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.maxWeight",
                    "name": "solver.LSQR.smoothing.maxWeight",
                    "value": "3.e+6",
                    "default": "3.e+6",
                    "description": "Final smoothing weight (after",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.level",
                    "name": "solver.LSQR.smoothing.level",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "The smoothing level, e.g. weight^2 Zero corresponds to maximum smoothing, and higher values to less smooth solutions.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.LSQR.smoothing.nsteps",
                    "name": "solver.LSQR.smoothing.nsteps",
                    "value": "10",
                    "default": "10",
                    "description": "The number of major cycles during which the smoothing weight is increased from",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.imagetype",
                    "name": "Cbpcalibrator.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Type of the image handler (determines the format of the images read from the disk). The default is to read casa format and this is the only option implemented so far.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.nAnt",
                    "name": "Cbpcalibrator.nAnt",
                    "value": "36",
                    "default": "36",
                    "description": "Number of antennas to solve bandpasses for. The code will fail if it is requested to solve for more antennas than it has the data for",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.nBeam",
                    "name": "Cbpcalibrator.nBeam",
                    "value": "1",
                    "default": "1",
                    "description": "Number of beams to solve for. The code will fail if it is requested to solve for more beams than it has the data for",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.beamindices",
                    "name": "Cbpcalibrator.beamindices",
                    "value": "None",
                    "default": "None",
                    "description": "This parameter enables solving for an arbitrary subset of beams. If given, then the length of the vector should match",
                    "readonly": false,
                    "type": "vector<uint>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.dataset",
                    "name": "Cbpcalibrator.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "Data set file name to produce. If the parameter is given as a vector of Strings, it is interpreted as one dataset per beam. Therefore, the length of the String should be either 1 or the number of beams.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.minrank",
                    "name": "Cbpcalibrator.minrank",
                    "value": "15",
                    "default": "15",
                    "description": "The smallest rank of the normal matrix when the calibration solution is considered to be valid. The default value of 15 corresponds to the case of",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.datacolumn",
                    "name": "Cbpcalibrator.datacolumn",
                    "value": "DATA",
                    "default": "DATA",
                    "description": "The name of the data column in the measurement set which will be the source of visibilities.This can be useful to process real telescope data which were passed through",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.nUVWMachines",
                    "name": "Cbpcalibrator.nUVWMachines",
                    "value": "1",
                    "default": "1",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.uvwMachineDirTolerance",
                    "name": "Cbpcalibrator.uvwMachineDirTolerance",
                    "value": "1e-6rad",
                    "default": "1e-6rad",
                    "description": "Direction tolerance for the management of the uvw-machine cache (see",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.refantenna",
                    "name": "Cbpcalibrator.refantenna",
                    "value": "-1",
                    "default": "-1",
                    "description": "If not negative, this is assumed to be the index of the reference antenna. All phases in the resulting bandpass are rotated so the chosen antenna has zero phase for all beams and all channels",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.sources.definition",
                    "name": "Cbpcalibrator.sources.definition",
                    "value": "",
                    "default": "",
                    "description": "Optional parameter. If defined, the sky model (i.e. source info given with",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.gridder",
                    "name": "Cbpcalibrator.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.rankstoringcf",
                    "name": "Cbpcalibrator.rankstoringcf",
                    "value": "1",
                    "default": "1",
                    "description": "In the parallel mode, only this rank will attempt to export convolution functions if this operation is requested (see",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.visweights",
                    "name": "Cbpcalibrator.visweights",
                    "value": "",
                    "default": "",
                    "description": "If this parameter is set to \"MFS\" gridders are setup to degrid with the weight required for the models given as Taylor series (i.e. multi-frequency synthesis models). At the moment, this parameter is decoupled from the setup of the model parameters. The user has to set it separately and in a consistent way with the model setup (the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.visweights.MFS.reffreq",
                    "name": "Cbpcalibrator.visweights.MFS.reffreq",
                    "value": "1.405e9",
                    "default": "1.405e9",
                    "description": "Reference frequency in Hz for MFS-model simulation (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.ncycles",
                    "name": "Cbpcalibrator.ncycles",
                    "value": "1",
                    "default": "1",
                    "description": "Number of solving iterations (and iterations over the dataset, which can be called major cycles).",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.freqframe",
                    "name": "Cbpcalibrator.freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.calibaccess",
                    "name": "Cbpcalibrator.calibaccess",
                    "value": "parset",
                    "default": "parset",
                    "description": "The destination for the calibration solution. Note, the default",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.solver",
                    "name": "Cbpcalibrator.solver",
                    "value": "SVD",
                    "default": "SVD",
                    "description": "Name of the calibration solver. Further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.solve",
                    "name": "Cbpcalibrator.solve",
                    "value": "bandpass",
                    "default": "bandpass",
                    "description": "String describing what to solve for (e.g. \u201cbandpass,leakages\u201d or \u201cleakages\u201d or \u201cbandpass\u201d). Note that leakages here means channel dependent leakages.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.store",
                    "name": "Cbpcalibrator.store",
                    "value": "what is in",
                    "default": "what is in",
                    "description": "This parameter accepts the same keywords as the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.xpol_only",
                    "name": "Cbpcalibrator.xpol_only",
                    "value": "false",
                    "default": "false",
                    "description": "If true, parallel-hand polarisation products will be ignored when calibration equations are made, i.e. the solution will be made based on cross-pol data only. This option can only be used for leakage-only solution and is an alternative way (with different systematics and assumptions) to make the calibration solution more robust.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.solution_time",
                    "name": "Cbpcalibrator.solution_time",
                    "value": "undefined",
                    "default": "undefined",
                    "description": "If defined, the solution will be tagged with the time given by the value of this parameter (interpreted as days of the MJD epoch). Otherwise, the earliest timestamp of data is used. This parameter may be handy for backward extrapolation of the calibration. Set it to some very early MJD epoch (e.g. zero) to effectively make the calibration solution applicable to all data.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.threshold.gain.enable",
                    "name": "Cbpcalibrator.threshold.gain.enable",
                    "value": "false",
                    "default": "false",
                    "description": "If true, gain (i.e. bandpass) is used for quality check. All solutions (i.e. bandpass and leakages, all polarisations) will be flagged for the given antenna, beam and channel if any of the gains is outside the tolerance.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.threshold.gain.tolerance",
                    "name": "Cbpcalibrator.threshold.gain.tolerance",
                    "value": "none",
                    "default": "none",
                    "description": "Tolerance for gain (i.e. bandpass value for the given channel, beam, polarisation) deviation from the expected value. Gains with amplitude outside the (expected - tolerance, expected + tolerance) range will trigger invalidation of the whole solution for the particular antenna, beam and channel.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.threshold.gain.expected",
                    "name": "Cbpcalibrator.threshold.gain.expected",
                    "value": "1.0",
                    "default": "1.0",
                    "description": "Expected value for gain (i.e. bandpass value for the given channel, beam, polarisation). See the two parameters above for the description of the thresholding logic.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.threshold.leakage.enable",
                    "name": "Cbpcalibrator.threshold.leakage.enable",
                    "value": "false",
                    "default": "false",
                    "description": "Similarly to",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cbpcalibrator.threshold.leakage.tolerance",
                    "name": "Cbpcalibrator.threshold.leakage.tolerance",
                    "value": "none",
                    "default": "none",
                    "description": "Similarly to",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "dataset",
                    "name": "dataset",
                    "value": "None",
                    "default": "None",
                    "description": "The name of the measurement set to which the calibration parameters will be applied. In the parallel mode with the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibrate.scalenoise",
                    "name": "calibrate.scalenoise",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the noise estimate will be scaled in accordance with the applied calibrator factor to achieve proper weighting.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibrate.allowflag",
                    "name": "calibrate.allowflag",
                    "value": "false",
                    "default": "false",
                    "description": "If true, corresponding visibilities are flagged if the inversion of Mueller matrix fails. Otherwise, an exception is thrown should the matrix inversion fail",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibrate.ignorebeam",
                    "name": "calibrate.ignorebeam",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the calibration solution corresponding to beam 0 will be applied to all beams",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "calibrate.ignorechannel",
                    "name": "calibrate.ignorechannel",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the same calibration solution will be applied to all channels. Use this to speed up the application of selfcal gains.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "freqframe",
                    "name": "freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "maxchunkrows",
                    "name": "maxchunkrows",
                    "value": "max integer",
                    "default": "max integer",
                    "description": "If defined, the chunk size presented at each iterat\\ ion will be restricted to have at most this number of rows. It doesn't affect the result, but may give different performance in the case of long spectral axis (think of it as a slice in rows will be taken once and then each spectral slice will be made from this reduced cube for the price of having more iterations).",
                    "readonly": false,
                    "type": "unsigned int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "distribute",
                    "name": "distribute",
                    "value": "true",
                    "default": "true",
                    "description": "If the application is executed in the parallel mode (i.e. more than one rank is available) and this option is true, the data are split in frequency between all available workers (i.e. ranks with non-\\ zero numbers) which do calibration application. The master rank (always rank 0) writes the result to the measurement set. If this option is false, each rank is expected to deal with its own measurement set and its own reading, calibration application and writing. Note, there is no master in this mode. So the substitution rules should use rank (r) rather than the worker (w) number. This option has no effect in the serial mode.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.imagetype",
                    "name": "Ccalibrator.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Type of the image handler (determines the format of the images read from the disk). The default is to read casa format and this is the only option implemented so far.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.nAnt",
                    "name": "Ccalibrator.nAnt",
                    "value": "36",
                    "default": "36",
                    "description": "Number of antennas to solve the gains for. The code will fail if it is requested to solve for more antennas than it has the data for",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.nBeam",
                    "name": "Ccalibrator.nBeam",
                    "value": "1",
                    "default": "1",
                    "description": "Number of beams to solve the gains for. The code will fail if it is requested to solve for more beams than it has the data for",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.interval",
                    "name": "Ccalibrator.interval",
                    "value": "-1s",
                    "default": "-1s",
                    "description": "If a positive number is given, a separate calibration solution will be made for each chunk of visibilities obtained within the time interval equal to the value of this parameter. For a negative value, a single solution is made for the whole dataset",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.dataset",
                    "name": "Ccalibrator.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "File name of the measurement set that is to be calibrated. Ccalibrator will not write to the file - use",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.datacolumn",
                    "name": "Ccalibrator.datacolumn",
                    "value": "DATA",
                    "default": "DATA",
                    "description": "The name of the data column in the measurement set which will be the source of visibilities.This can be useful to process real telescope data which were passed through",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.nUVWMachines",
                    "name": "Ccalibrator.nUVWMachines",
                    "value": "1",
                    "default": "1",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.uvwMachineDirTolerance",
                    "name": "Ccalibrator.uvwMachineDirTolerance",
                    "value": "1e-6rad",
                    "default": "1e-6rad",
                    "description": "Direction tolerance for the management of the uvw-machine cache (see",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.refgain",
                    "name": "Ccalibrator.refgain",
                    "value": "",
                    "default": "",
                    "description": "If not an empty String, this is assumed to be the name of the reference gain parameter (and so it must exist, otherwise an exception will be thrown), i.e.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.refantenna",
                    "name": "Ccalibrator.refantenna",
                    "value": "None",
                    "default": "None",
                    "description": "If a valid antenna number is given (in the range [0,nAnt-1]), this antenna is used for phase referencing. The phases of the resulting gains are rotated by the appropriate polarisation of the reference antenna, such that the reference X and Y gains are both zero phase. Leakages are referenced against the XY phase difference of the reference antenna.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.solve",
                    "name": "Ccalibrator.solve",
                    "value": "gains",
                    "default": "gains",
                    "description": "String describing what to solve for (e.g. \"gains,leakages\" or \"leakages\" or \"gains\"). If \"antennagains\" or \"antennaleakages\" is used instead of \"gains\" or \"leakages\", beam-independent gains or leakages are solved for. Such a solution is stored as beam=0 solution. Use",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.normalisegains",
                    "name": "Ccalibrator.normalisegains",
                    "value": "false",
                    "default": "false",
                    "description": "Optional parameter. If defined, and if solving for \"gains\", the newly found antenna gains will have their amplitdues set to unity when they are written to file. This is in lieu of true phase-only gain calibration and should be used with care.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.sources.definition",
                    "name": "Ccalibrator.sources.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, sky model (i.e. source info given as",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.gridder",
                    "name": "Ccalibrator.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.rankstoringcf",
                    "name": "Ccalibrator.rankstoringcf",
                    "value": "1",
                    "default": "1",
                    "description": "In the parallel mode, only this rank will attempt to export convolution functions if this operation is requested (see",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.visweights",
                    "name": "Ccalibrator.visweights",
                    "value": "",
                    "default": "",
                    "description": "If this parameter is set to \"MFS\" gridders are setup to degrid with the weight required for the models given as Taylor series (i.e. multi-frequency synthesis models). At the moment, this parameter is decoupled from the setup of the model parameters. The user has to set it separately and in a consistent way with the model setup (the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.visweights.MFS.reffreq",
                    "name": "Ccalibrator.visweights.MFS.reffreq",
                    "value": "1.405e9",
                    "default": "1.405e9",
                    "description": "Reference frequency in Hz for MFS-model simulation (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.ncycles",
                    "name": "Ccalibrator.ncycles",
                    "value": "1",
                    "default": "1",
                    "description": "Number of solving iterations (and iterations over the dataset, which can be called major cycles).",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.freqframe",
                    "name": "Ccalibrator.freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Ccalibrator.solver",
                    "name": "Ccalibrator.solver",
                    "value": "SVD",
                    "default": "SVD",
                    "description": "Name of the calibration solver. Further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.imagetype",
                    "name": "CContSubtract.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Type of the image handler (determines the format of the images read from the disk). The default is to read casa images, fits is the other option.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.dataset",
                    "name": "CContSubtract.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "Data set file name to work with. The visibility data are overwritten with the subtraction result. Usual substitution rules apply.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.datacolumn",
                    "name": "CContSubtract.datacolumn",
                    "value": "DATA",
                    "default": "DATA",
                    "description": "The name of the data column in the measurement set which will be the source of visibilities and which will be updated. This can be useful to process real telescope data which were passed through",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.sources.definition",
                    "name": "CContSubtract.sources.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, sky model (i.e. source info given as",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.gridder",
                    "name": "CContSubtract.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.visweights",
                    "name": "CContSubtract.visweights",
                    "value": "",
                    "default": "",
                    "description": "If this parameter is set to \"MFS\" gridders are setup to degrid with the weight required for the models given as Taylor series (i.e. multi-frequency synthesis models). At the moment, this parameter is decoupled from the setup of the model parameters.The user has to set it separately and in a consistent way with the model setup (the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.visweights.MFS.reffreq",
                    "name": "CContSubtract.visweights.MFS.reffreq",
                    "value": "1.405e9",
                    "default": "1.405e9",
                    "description": "Reference frequency in Hz for MFS-model simulation (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.modelReadByMaster",
                    "name": "CContSubtract.modelReadByMaster",
                    "value": "true",
                    "default": "true",
                    "description": "This parameter has effect in the parallel case only (can be set to anything in the serial case without affecting the result). If true, the sky model is read by the master and is then distributed to all workers. If false, each worker reads the model, which should be accessible from the worker nodes. This approach cuts down communication when the model is too big. Workers can also use individual models with the help of the substitution mechanism.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.nUVWMachines",
                    "name": "CContSubtract.nUVWMachines",
                    "value": "1",
                    "default": "1",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered in the dataset. In the non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.uvwMachineDirTolerance",
                    "name": "CContSubtract.uvwMachineDirTolerance",
                    "value": "1e-6rad",
                    "default": "1e-6rad",
                    "description": "Direction tolerance for the management of the uvw-machine cache (see",
                    "readonly": false,
                    "type": "quantity",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.freqframe",
                    "name": "CContSubtract.freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.doUVlin",
                    "name": "CContSubtract.doUVlin",
                    "value": "false",
                    "default": "false",
                    "description": "Set to true to fit the visibility spectra to derive a continuum model and subtract it.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.order",
                    "name": "CContSubtract.order",
                    "value": "1",
                    "default": "1",
                    "description": "Order of the polynomial to fit. The default is linear.",
                    "readonly": false,
                    "type": "integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.harmonic",
                    "name": "CContSubtract.harmonic",
                    "value": "1",
                    "default": "1",
                    "description": "nchan), with n the 'harmonic order'. Increasing harmonic by one adds 2 degrees of freedom.",
                    "readonly": false,
                    "type": "integer",
                    "precious": false,
                    "options": [
                        "Number of sine and cosine terms to fit. Higher harmonics vary faster across the channel width",
                        " i.e.",
                        " sin(n*pi*chan"
                    ],
                    "positional": false
                },
                {
                    "text": "CContSubtract.width",
                    "name": "CContSubtract.width",
                    "value": "0",
                    "default": "0",
                    "description": "Fit in bins of 'width' channels. The default fits to the entire spectrum. Smaller bins (and more degrees of freedom) allow sources further from the phase center to be be removed.",
                    "readonly": false,
                    "type": "integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.offset",
                    "name": "CContSubtract.offset",
                    "value": "0",
                    "default": "0",
                    "description": "The offset allows you to shift the origin of the fitting bins left. The first and last bin may be smaller. This feature exists to let you match the bins to e.g., the beam-forming intervals.",
                    "readonly": false,
                    "type": "integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "CContSubtract.threshold",
                    "name": "CContSubtract.threshold",
                    "value": "2.5",
                    "default": "2.5",
                    "description": "Exclude outliers from the continuum fit. This first determines a robust estimate of rms and then rejects channels more than threshold*rms from the model. Iterates up to 3 times. Set to zero to skip thresholding.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.dataset",
                    "name": "Cddcalibrator.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "File name of the measurement set that is to be calibrated. Cddcalibrator will not write to the file - use",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.solve",
                    "name": "Cddcalibrator.solve",
                    "value": "gains",
                    "default": "gains",
                    "description": "String describing what to solve for. Only \"gains\" and \"ionosphere\" are currently supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.interval",
                    "name": "Cddcalibrator.interval",
                    "value": "-1s",
                    "default": "-1s",
                    "description": "If a positive number is given, a separate calibration solution will be made for each chunk of visibilities obtained within the time interval equal to the value of this parameter. For a negative value, a single solution is made for the whole dataset",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.solver",
                    "name": "Cddcalibrator.solver",
                    "value": "SVD",
                    "default": "SVD",
                    "description": "Name of the calibration solver. Further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.ncycles",
                    "name": "Cddcalibrator.ncycles",
                    "value": "1",
                    "default": "1",
                    "description": "Number of solving iterations (and iterations over the dataset, which can be called major cycles).",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.nAnt",
                    "name": "Cddcalibrator.nAnt",
                    "value": "36",
                    "default": "36",
                    "description": "Number of antennas in the data buffers, and for gain calibration, the number of antennas to solve for. The code will fail if a requested is made to solve for more antennas than it has the data for.",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.nChan",
                    "name": "Cddcalibrator.nChan",
                    "value": "1",
                    "default": "1",
                    "description": "Number of frequency channels in the data buffers. For gain calibration this will be 1, however for ionospheric calibration there nChan should equal the number of frequency channels in the dataset.",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.nCal",
                    "name": "Cddcalibrator.nCal",
                    "value": "1",
                    "default": "1",
                    "description": "Number of simultaneous directions to solve for. The code will fail if the number of directions does not match the number of source names in the sky model.",
                    "readonly": false,
                    "type": "uint",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.freqframe",
                    "name": "Cddcalibrator.freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.refantenna",
                    "name": "Cddcalibrator.refantenna",
                    "value": "None",
                    "default": "None",
                    "description": "If a valid antenna number is given (in the range [0,nAnt-1]), this antenna is used for phase referencing. The phases of the resulting gains are rotated by the appropriate polarisation of the reference antenna, such that the reference X and Y gains are both zero phase. Leakages are referenced against the XY phase difference of the reference antenna.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.normalisegains",
                    "name": "Cddcalibrator.normalisegains",
                    "value": "false",
                    "default": "false",
                    "description": "Optional parameter. If defined, and if solving for \"gains\", the newly found antenna gains will have their amplitdues set to unity when they are written to file. This is in lieu of true phase-only gain calibration and should be used with care.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.datacolumn",
                    "name": "Cddcalibrator.datacolumn",
                    "value": "DATA",
                    "default": "DATA",
                    "description": "The name of the data column in the measurement set which will be the source of visibilities.This can be useful to process real telescope data which were passed through",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.nUVWMachines",
                    "name": "Cddcalibrator.nUVWMachines",
                    "value": "1",
                    "default": "1",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.uvwMachineDirTolerance",
                    "name": "Cddcalibrator.uvwMachineDirTolerance",
                    "value": "1e-6rad",
                    "default": "1e-6rad",
                    "description": "Direction tolerance for the management of the uvw-machine cache (see",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.sources.definition",
                    "name": "Cddcalibrator.sources.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, sky model (i.e. source info given as",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.imagetype",
                    "name": "Cddcalibrator.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Format of images used for image-based sky models.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.gridder",
                    "name": "Cddcalibrator.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.rankstoringcf",
                    "name": "Cddcalibrator.rankstoringcf",
                    "value": "1",
                    "default": "1",
                    "description": "In the parallel mode, only this rank will attempt to export convolution functions if this operation is requested (see",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.visweights",
                    "name": "Cddcalibrator.visweights",
                    "value": "",
                    "default": "",
                    "description": "If this parameter is set to \"MFS\" gridders are setup to degrid with the weight required for the models given as Taylor series (i.e. multi-frequency synthesis models). At the moment, this parameter is decoupled from the setup of the model parameters. The user has to set it separately and in a consistent way with the model setup (the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.visweights.MFS.reffreq",
                    "name": "Cddcalibrator.visweights.MFS.reffreq",
                    "value": "1.405e9",
                    "default": "1.405e9",
                    "description": "Reference frequency in Hz for MFS-model simulation (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.frequencies",
                    "name": "Cddcalibrator.frequencies",
                    "value": "None",
                    "default": "None",
                    "description": "A 3-element vector describing the spectral window of the dataset, containing the number of channels, frequency of the first channel (quantity) and frequency increment (quantity) (e.g. [50, 125MHz, 1MHz]).",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cddcalibrator.antennas.definition",
                    "name": "Cddcalibrator.antennas.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Specify an antenna layout file. See :doc:",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.dataset",
                    "name": "Cflag.dataset",
                    "value": "fornax.ms",
                    "default": "fornax.ms",
                    "description": "The measurement set (uv-dataset) to be flagged. This file has flagging applied in place (i.e. it is modified)",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.dryrun",
                    "name": "Cflag.dryrun",
                    "value": "true",
                    "default": "true",
                    "description": "If set to true, the dataset will not be modified. The flaggers will still report flagging information so the user can see what flagging would have taken place if \"dryrun\" was set to false.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.summary",
                    "name": "Cflag.summary",
                    "value": "false",
                    "default": "false",
                    "description": "If \"true\" then a summary of the measurement set is displayed before flagging. This contains information such as previous flagging. However, an extra pass over the data is done, so for very large measurement sets this can be avoided by setting this parameter to \"false\"",
                    "readonly": false,
                    "type": "true",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.rules",
                    "name": "Cflag.selection_flagger.rules",
                    "value": "[rule1, rule2]",
                    "default": "[rule1, rule2]",
                    "description": "The list of rules for selection based flagging. If this parameter is not specified, the selection based flagger is not used.",
                    "readonly": false,
                    "type": "None",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.field",
                    "name": "Cflag.selection_flagger.<rule>.field",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag based on field index number",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.spw",
                    "name": "Cflag.selection_flagger.<rule>.spw",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag based on spectral window",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.antenna",
                    "name": "Cflag.selection_flagger.<rule>.antenna",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag based on an antenna or antenna pair",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.timerange",
                    "name": "Cflag.selection_flagger.<rule>.timerange",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag based on a time range",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.correlation",
                    "name": "Cflag.selection_flagger.<rule>.correlation",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag specific correlation products",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.scan",
                    "name": "Cflag.selection_flagger.<rule>.scan",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag all rows in a given scan, based on scan index number",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.feed",
                    "name": "Cflag.selection_flagger.<rule>.feed",
                    "value": "[0, 1]",
                    "default": "[0, 1]",
                    "description": "An array of beam index numbers to flag.",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.uvrange",
                    "name": "Cflag.selection_flagger.<rule>.uvrange",
                    "value": "See below URL",
                    "default": "See below URL",
                    "description": "Flag all baselines for a given UV distance range",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.selection_flagger.<rule>.autocorr",
                    "name": "Cflag.selection_flagger.<rule>.autocorr",
                    "value": "true",
                    "default": "true",
                    "description": "Flag auto correlations",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.elevation_flagger.enable",
                    "name": "Cflag.elevation_flagger.enable",
                    "value": "true",
                    "default": "true",
                    "description": "Enable the elevation thresholding based flagging",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.elevation_flagger.low",
                    "name": "Cflag.elevation_flagger.low",
                    "value": "10.0",
                    "default": "10.0",
                    "description": "Defines the lower threshold (in degrees). All visibilities for which the elevation was lowever than this threshold will be flagged.",
                    "readonly": false,
                    "type": "0.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.elevation_flagger.high",
                    "name": "Cflag.elevation_flagger.high",
                    "value": "89.5",
                    "default": "89.5",
                    "description": "Defines the upper threshold (in degrees). All visibilities for which the elevation was higher than this threshold will be flagged.",
                    "readonly": false,
                    "type": "90.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.enable",
                    "name": "Cflag.stokesv_flagger.enable",
                    "value": "true",
                    "default": "true",
                    "description": "Enable the Stokes-V dynamic flagging",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.threshold",
                    "name": "Cflag.stokesv_flagger.threshold",
                    "value": "5.0",
                    "default": "5.0",
                    "description": "The threshold at which visibilities will be flagged. Where the amplitude of a correlation exceeds the (average + (stddev * threshold)) all correlations for that spectral channel in the row will be flagged.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.useRobustStatistics",
                    "name": "Cflag.stokesv_flagger.useRobustStatistics",
                    "value": "true",
                    "default": "true",
                    "description": "Use the median and interquartile range to estimate average and stddev (see below).",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.integrateSpectra",
                    "name": "Cflag.stokesv_flagger.integrateSpectra",
                    "value": "true",
                    "default": "true",
                    "description": "Integrate the spectra in time and flag any channels outside bounds, set using the robust statistics described below. Uses scalar averaging. Spectra for different baselines, beams, fields and polarisation are kept separate. Requires a second pass over the data.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.integrateSpectra.threshold",
                    "name": "Cflag.stokesv_flagger.integrateSpectra.threshold",
                    "value": "4.0",
                    "default": "4.0",
                    "description": "The threshold factor used to bound integrated spectra.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.integrateTimes",
                    "name": "Cflag.stokesv_flagger.integrateTimes",
                    "value": "true",
                    "default": "true",
                    "description": "Integrate across spectra and flag any time samples outside bounds, set using the robust statistics described below. Uses scalar averaging. Series for different baselines, beams, fields and polarisation are kept separate. Requires a second pass over the data.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.stokesv_flagger.integrateTimes.threshold",
                    "name": "Cflag.stokesv_flagger.integrateTimes.threshold",
                    "value": "4.0",
                    "default": "4.0",
                    "description": "The threshold factor used to bound integrated spectra.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.enable",
                    "name": "Cflag.amplitude_flagger.enable",
                    "value": "true",
                    "default": "true",
                    "description": "Enable amplitude threshold flagging",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.low",
                    "name": "Cflag.amplitude_flagger.low",
                    "value": "1e-17",
                    "default": "1e-17",
                    "description": "The lower bound for valid visibilities. Any visibility with a lower amplitude will be flagged. If this parameter is not present in the parset, then no lower bound will be enforced.",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.high",
                    "name": "Cflag.amplitude_flagger.high",
                    "value": "12345.0",
                    "default": "12345.0",
                    "description": "The upper bound for valid visibilities. Any visibility with a higher amplitude will be flagged. If this parameter is not present in the parset, then no upper bound will be enforced.",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.stokes",
                    "name": "Cflag.amplitude_flagger.stokes",
                    "value": "[XX, YY]",
                    "default": "[XX, YY]",
                    "description": "Specifies which correlation products are to be subject to flagging. If this parameter is not specified then",
                    "readonly": false,
                    "type": "*None*",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.dynamicBounds",
                    "name": "Cflag.amplitude_flagger.dynamicBounds",
                    "value": "true",
                    "default": "true",
                    "description": "If true, automatically generate low and high amplitude bounds for each spectrum using the statistics described below. Both Cflag.amplitude_flagger.low and Cflag.amplitude_flagger.high have preference over the dynamic bounds.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.threshold",
                    "name": "Cflag.amplitude_flagger.threshold",
                    "value": "4.0",
                    "default": "4.0",
                    "description": "The threshold factor used in the statistics described below.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.integrateSpectra",
                    "name": "Cflag.amplitude_flagger.integrateSpectra",
                    "value": "true",
                    "default": "true",
                    "description": "Integrate the spectra in time and flag any channels outside bounds, also set using the robust statistics described below. Uses scalar averaging. Spectra for different baselines, beams, fields and polarisation are kept separate. Requires a second pass over the data.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.integrateSpectra.threshold",
                    "name": "Cflag.amplitude_flagger.integrateSpectra.threshold",
                    "value": "4.0",
                    "default": "4.0",
                    "description": "The threshold factor used to bound integrated spectra.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.integrateTimes",
                    "name": "Cflag.amplitude_flagger.integrateTimes",
                    "value": "true",
                    "default": "true",
                    "description": "Integrate across spectra and flag any time samples outside bounds, also set using the robust statistics described below. Uses scalar averaging. Series for different baselines, beams, fields and polarisation are kept separate. Requires a second pass over the data.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.integrateTimes.threshold",
                    "name": "Cflag.amplitude_flagger.integrateTimes.threshold",
                    "value": "4.0",
                    "default": "4.0",
                    "description": "The threshold factor used to bound integrated spectra.",
                    "readonly": false,
                    "type": "5.0",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.aveAll",
                    "name": "Cflag.amplitude_flagger.aveAll",
                    "value": "true",
                    "default": "true",
                    "description": "Do not separate spectra based on baseline, etc., when integrating spectra or time series. Average everything together.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.aveAll.noPol",
                    "name": "Cflag.amplitude_flagger.aveAll.noPol",
                    "value": "true",
                    "default": "true",
                    "description": "Do separate spectra for different polarisations.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cflag.amplitude_flagger.aveAll.noBeam",
                    "name": "Cflag.amplitude_flagger.aveAll.noBeam",
                    "value": "true",
                    "default": "true",
                    "description": "Do separate spectra for different beams.",
                    "readonly": false,
                    "type": "false",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.imagetype",
                    "name": "Cimager.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Type of the image handler (determines the format of the images, both which are written to or read from the disk). Either \"fits\" or \"casa\" can be requested.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.dataset",
                    "name": "Cimager.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "Measurement set file name to read from. Usual substitution rules apply if the parameter is a single String. If the parameter is given as a vector of Strings all measurement sets given by this vector are effectively concatenated together on-the-fly in the serial case. In the parallel case, the size of the vector is required to be either 1 or the number of nodes - 1, and therefore there is one measurement set per worker node.",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.nworkergroups",
                    "name": "Cimager.nworkergroups",
                    "value": "1",
                    "default": "1",
                    "description": "Number of worker groups. This option can only be used in the parallel mode. If it is greater than 1, the model parameters are distributed (as evenly as possible) between the given number of groups of workers (e.g. if one calculates a Taylor term expansion of the order of 1 for one image, setting this parameter to 3 will allow parallel computation of the Taylor terms for this image). This is on top of the normal parallelism within the group (the w index spans from 0 to the number of workers per group - 1). Essentially, this option allows to throw several workers on the same problem if the model allows partitioning.Taylor terms, faceting and multiple images in the model are the typical use cases.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.datacolumn",
                    "name": "Cimager.datacolumn",
                    "value": "DATA",
                    "default": "DATA",
                    "description": "The name of the data column in the measurement set which will be the source of visibilities.This can be useful to process real telescope data which were passed through",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.sphfuncforpsf",
                    "name": "Cimager.sphfuncforpsf",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the default spheroidal function gridder is used to compute PSF regardless of the gridder selected for model degridding and residual gridding. This has a potential to produce better behaving PSF by taking out two major factors of position dependence. Note, this doesn't make the PSF correct or otherwise,it is just a different approximation",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.calibrate",
                    "name": "Cimager.calibrate",
                    "value": "false",
                    "default": "false",
                    "description": "If true, calibration of visibilities will be performed before imaging. See :doc:",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.calibrate.scalenoise",
                    "name": "Cimager.calibrate.scalenoise",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the noise estimate will be scaled in accordance with the applied calibrator factor to achieve proper weighting.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.calibrate.allowflag",
                    "name": "Cimager.calibrate.allowflag",
                    "value": "false",
                    "default": "false",
                    "description": "If true, corresponding visibilities are flagged if the inversion of Mueller matrix fails. Otherwise, an exception is thrown should the matrix inversion fail",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.calibrate.ignorebeam",
                    "name": "Cimager.calibrate.ignorebeam",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the calibration solution corresponding to beam 0 will be applied to all beams",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.gainsfile",
                    "name": "Cimager.gainsfile",
                    "value": "",
                    "default": "",
                    "description": "This is an obsolete parameter, which is still supported for backwards compatibility defining the file with antenna gains (a parset format, keywords look like",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore",
                    "name": "Cimager.restore",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the image will be restored (by convolving with the given 2D gaussian). This is an additional step to normal imaging, which, by default, ends with just a model image. The restored image is written into a separate image file (with the **.restored** suffix). The convolution is done with the restore solver (see also :doc:",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.residuals",
                    "name": "Cimager.residuals",
                    "value": "true",
                    "default": "true",
                    "description": "If true write out the residual image.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore.beam",
                    "name": "Cimager.restore.beam",
                    "value": "None",
                    "default": "None",
                    "description": "Either a single word",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore.beam.cutoff",
                    "name": "Cimager.restore.beam.cutoff",
                    "value": "0.05",
                    "default": "0.05",
                    "description": "Cutoff for the support search prior to beam fitting, as a fraction of the PSF peak. This parameter is only used if",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore.preconditioner.xxx",
                    "name": "Cimager.restore.preconditioner.xxx",
                    "value": "None",
                    "default": "None",
                    "description": "Specify an additional preconditioner to be used when restoring. This will result in an a second set of restored files with the **.alt.restored** suffix. See",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore.equalise",
                    "name": "Cimager.restore.equalise",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the final residual is multiplied by the square root of the truncated normalised weight (i.e. additional weight described by Sault et al. (1996), which gives a flat noise). Note, that the source flux densities are likely to have position-dependent errors if this option is used because not all flux is recovered during the clean process. However, the images look aesthetically pleasing with this option.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.restore.updateresiduals",
                    "name": "Cimager.restore.updateresiduals",
                    "value": "true",
                    "default": "true",
                    "description": "The residual image written out by the restore solver can be updated using the latest model. This is now the default behviour. Note the majorcycle outputs do not pass through the restore solver so are not updated so therefore correspond to the residuals at the beginning of the last minor cycle.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.nUVWMachines",
                    "name": "Cimager.nUVWMachines",
                    "value": "1",
                    "default": "1",
                    "description": "Size of uvw-machines cache. uvw-machines are used to convert uvw from a given phase centre to a common tangent point. To reduce the cost to set the machine up (calculation of the transformation matrix), a number of these machines is cached. The key to the cache is a pair of two directions: the current phase centre and the tangent centre. If the required pair is within the tolerances of that used to setup one of the machines in the cache, this machine is reused. If none of the cache items matches the least accessed one is replaced by the new machine which is set up with the new pair of directions. The code would work faster if this parameter is set to the number of phase centres encountered during imaging. In non-faceting case, the optimal setting would be the number of synthetic beams times the number of fields. For faceting (btw, the performance gain is quite significant in this case), it should be further multiplied by the number of facets. Direction tolerances are given as a separate parameter.",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.uvwMachineDirTolerance",
                    "name": "Cimager.uvwMachineDirTolerance",
                    "value": "1e-6rad",
                    "default": "1e-6rad",
                    "description": "Direction tolerance for the management of the uvw-machine cache (see",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.gridder",
                    "name": "Cimager.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.includeflagged",
                    "name": "Cimager.includeflagged",
                    "value": "true",
                    "default": "true",
                    "description": "By default the flags are ignored when scanning through the data for ranges of frequencies, uvw values and other parameters because this is faster. Set to false to exclude flagged data and make the advice more accurate. Flagged data are always excluded during imaging.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.rankstoringcf",
                    "name": "Cimager.rankstoringcf",
                    "value": "1",
                    "default": "1",
                    "description": "In the parallel mode, only this rank will attempt to export convolution functions if this operation is requested (see",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.visweights",
                    "name": "Cimager.visweights",
                    "value": "MFS if any",
                    "default": "MFS if any",
                    "description": "degrid with the weight required for multi-frequency synthesis. At the moment, this parameter is decoupled from the image setup, which has to be done separately in a consistent way to use MSMFS (",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [
                        "If this parameter is set to \"MFS\" gridders are setup to grid"
                    ],
                    "positional": false
                },
                {
                    "text": "Cimager.visweights.MFS.reffreq",
                    "name": "Cimager.visweights.MFS.reffreq",
                    "value": "ave freq (see",
                    "default": "ave freq (see",
                    "description": "Reference frequency in Hz for MFS processing (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.solver",
                    "name": "Cimager.solver",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the solver, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.ncycles",
                    "name": "Cimager.ncycles",
                    "value": "0",
                    "default": "0",
                    "description": "Number of major cycles (and iterations over the dataset)",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.sensitivityimage",
                    "name": "Cimager.sensitivityimage",
                    "value": "true",
                    "default": "true",
                    "description": "If true, an image with theoretical sensitivity will be created in addition to weights image",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.sensitivityimage.cutoff",
                    "name": "Cimager.sensitivityimage.cutoff",
                    "value": "0.01",
                    "default": "0.01",
                    "description": "Desired cutoff in the sensitivity image",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.freqframe",
                    "name": "Cimager.freqframe",
                    "value": "topo",
                    "default": "topo",
                    "description": "Frequency frame to work in (the frame is converted when the dataset is read). Either lsrk or topo is supported.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.reuse",
                    "name": "Cimager.Images.reuse",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the model images will be read from the disk (from the image files they are normally written to according to the parset) before the first major cycle. If false (the default), a new empty model image will be initialised for every image solved for. Setting this parameter to true allows to continue cleaning the same image if more major cycles are required after inspection of the image. Note, there is little cross check that the image given as an input is actually a result of the previous run of cimager with the same Image parameters. So the user is responsible to ensure that the projection, shape, etc matches.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.shape",
                    "name": "Cimager.Images.shape",
                    "value": "1.7 * pb FWHM (~1st",
                    "default": "1.7 * pb FWHM (~1st",
                    "description": "Optional parameter to define the default shape for all images. If an individual",
                    "readonly": false,
                    "type": "vector<int>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.writeAtMajorCycle",
                    "name": "Cimager.Images.writeAtMajorCycle",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the current images are written to disk after each major cycle (*.cycle* suffix is added to the name to reflect which major cycle the image corresponds to). By default, the images are only written after",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.Names",
                    "name": "Cimager.Images.Names",
                    "value": "None",
                    "default": "None",
                    "description": "List of image names which this imager will produce. If more than one image is given, a superposition is assumed (i.e. visibilities are fitted with a combined effect of two images; two measurement equations are simply added). Parameters of each image defined in this list must be given in the same parset using",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.griddingcellsize",
                    "name": "Cimager.Images.griddingcellsize",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter to define the pixel size used during gridding, merging and preconditioning. Before cleaning or output, images are oversampled to the desired",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.nyquistgridding",
                    "name": "Cimager.Images.nyquistgridding",
                    "value": "false",
                    "default": "false",
                    "description": "Optional parameter to determine the",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.nchan",
                    "name": "Cimager.Images.*ImageName*.nchan",
                    "value": "1",
                    "default": "1",
                    "description": "Number of spectral planes in the image cube to produce. Set it to 1 if just a 2D image is required",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.frequency",
                    "name": "Cimager.Images.*ImageName*.frequency",
                    "value": "[min freq,max freq] if",
                    "default": "[min freq,max freq] if",
                    "description": "Frequencies in Hz of the first and the last spectral channels to produce in the cube. The range is binned into",
                    "readonly": false,
                    "type": "vector<Float>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.direction",
                    "name": "Cimager.Images.*ImageName*.direction",
                    "value": "phase centre of the",
                    "default": "phase centre of the",
                    "description": "Direction to the centre of the required image (or tangent point for facets). This vector should contain a 3-element direction quantity containing right ascension, declination and epoch, e.g. [12h30m00.00, -45.00.00.00, J2000]. Note that a casa style of declination delimiters (dots rather than colons) is essential. Only",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.tangent",
                    "name": "Cimager.Images.*ImageName*.tangent",
                    "value": "",
                    "default": "",
                    "description": "Direction to the user-defined tangent point, if different from the centre of the image. This vector should contain a 3-element direction quantity containing right ascension, declination and epoch, e.g. [12h30m00.00, -45.00.00.00, J2000] or be empty (in this case the tangent point will be in the image centre). Note that a casa style of declination delimiters (dots rather than colons) is essential. Only",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.ewprojection",
                    "name": "Cimager.Images.*ImageName*.ewprojection",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the image will be set up with the NCP or SCP projection appropriate for East-West arrays (w-term is equivalent to this coordinate transfer for East-West arrays)",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.shape",
                    "name": "Cimager.Images.*ImageName*.shape",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter if the default shape (without image name prefix) is defined. This value will override the default shape for this particular image. Must be a 2-element vector.",
                    "readonly": false,
                    "type": "vector<int>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.cellsize",
                    "name": "Cimager.Images.*ImageName*.cellsize",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter if the default cell size (without image name prefix) is defined. This value will override the default cell size for this particular image. A two-element vector of Strings is expected, e.g. [6.0arcsec, 6.0arcsec]",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.nfacets",
                    "name": "Cimager.Images.*ImageName*.nfacets",
                    "value": "1",
                    "default": "1",
                    "description": "Number of facets for the given image. If greater than one, the image centre is treated as a tangent point and",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.polarisation",
                    "name": "Cimager.Images.*ImageName*.polarisation",
                    "value": "[\"I\"]",
                    "default": "[\"I\"]",
                    "description": "Polarisation planes to be produced for the image (should have at least one). Polarisation conversion is done on-the-fly, so the output polarisation frame may differ from that of the dataset. An exception is thrown if there is insufficient information to obtain the requested polarisation (e.g. there are no cross-pols and full stokes cube is requested). Note, ASKAPsoft uses the",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.nterms",
                    "name": "Cimager.Images.*ImageName*.nterms",
                    "value": "1",
                    "default": "1",
                    "description": "Number of Taylor terms for the given image. If greater than one, a given number of Taylor terms is generated for the given image which are named ImageName.taylor.x, where x is the 0-based Taylor order (note, it can be combined with faceting causing the names to be more complex). This name substitution happens behind the scene (as for faceting) and a number of images (representing Taylor terms) is created instead of a single one. This option should be used in conjunction with",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Cimager.Images.*ImageName*.facetstep",
                    "name": "Cimager.Images.*ImageName*.facetstep",
                    "value": "min(shape(0),shape(1))",
                    "default": "min(shape(0),shape(1))",
                    "description": "Offset in tangent plane pixels between facet centres (assumed the same for both dimensions). The default value is the image size, which means no overlap between facets (no overlap on the shortest axis for rectangular images). Overlap may be required to achieve a reasonable dynamic range with faceting (aliasing from the sources located beyond the facet edge). The alternative way to address the same problem is the",
                    "readonly": false,
                    "type": "Integer",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.imagetype",
                    "name": "Csimulator.imagetype",
                    "value": "casa",
                    "default": "casa",
                    "description": "Type of the image handler (determines the format of the images read from the disk). The default is to read casa images and this is the only option implemented so far.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.dataset",
                    "name": "Csimulator.dataset",
                    "value": "None",
                    "default": "None",
                    "description": "Data set file name to produce. Usual substitution rules apply.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.definition",
                    "name": "Csimulator.sources.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, sky model (i.e. source info given as",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.antennas.definition",
                    "name": "Csimulator.antennas.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, antenna layout (",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.feeds.definition",
                    "name": "Csimulator.feeds.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, feed information (",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.spws.definition",
                    "name": "Csimulator.spws.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, configuration of spectral windows (i.e. which frequencies are observed) is read from a separate parset file, which name is given by this parameter. If not, the appropriate parameters (",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.definition",
                    "name": "Csimulator.simulation.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, additional parameters of simulations are read from a separate parset file (name is given by this parameter). If this parameter is not defined, these additional parameters (listed in a separate section below) must be given in the main parset file. Usual substitution rules apply.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.observe.definition",
                    "name": "Csimulator.observe.definition",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If defined, description of simulated observations is read from a separate parset file (name is given by this parameter). If this parameter is not defined, these details must be given in the main parset file (see the description in a separate section below).",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.visweights",
                    "name": "Csimulator.visweights",
                    "value": "",
                    "default": "",
                    "description": "If this parameter is set to \"MFS\" gridders are setup to degrid with the weight required for the models given as Taylor series (i.e. multi-frequency synthesis models). At the moment, this parameter is decoupled from the setup of the model parameters. The user has to set it separately and in a consistent way with the model setup (",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.visweights.MFS.reffreq",
                    "name": "Csimulator.visweights.MFS.reffreq",
                    "value": "1.405e9",
                    "default": "1.405e9",
                    "description": "Reference frequency in Hz for MFS-model simulation (see above)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.stman.bucketsize",
                    "name": "Csimulator.stman.bucketsize",
                    "value": "32768",
                    "default": "32768",
                    "description": "O size.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [
                        "Set the bucket size (in bytes) of the casa table storage manager. This usually translates to the I"
                    ],
                    "positional": false
                },
                {
                    "text": "Csimulator.stman.tilencorr",
                    "name": "Csimulator.stman.tilencorr",
                    "value": "4",
                    "default": "4",
                    "description": "Set the number of correlations per tile. This affects the way the table is stored on disk.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.stman.tilenchan",
                    "name": "Csimulator.stman.tilenchan",
                    "value": "32",
                    "default": "32",
                    "description": "Set the number of channels per tile. This affects the way the table is stored on disk.",
                    "readonly": false,
                    "type": "int32",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.gridder",
                    "name": "Csimulator.gridder",
                    "value": "None",
                    "default": "None",
                    "description": "Name of the gridder, further parameters are given by",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.corrupt",
                    "name": "Csimulator.corrupt",
                    "value": "False",
                    "default": "False",
                    "description": "if True, simulated data are corrupted by simulating calibration effects. See :doc:",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.corrupt.gainsfile",
                    "name": "Csimulator.corrupt.gainsfile",
                    "value": "None",
                    "default": "None",
                    "description": "leakages to apply if",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [
                        "This is a deprecated parameter",
                        " which will be removed in the future. It used to define the name of the file with gains"
                    ],
                    "positional": false
                },
                {
                    "text": "Csimulator.corrupt.leakage",
                    "name": "Csimulator.corrupt.leakage",
                    "value": "false",
                    "default": "false",
                    "description": "If true, polarisation leakage is simulated. Values will be taken from file referred to by gainsfile.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise",
                    "name": "Csimulator.noise",
                    "value": "false",
                    "default": "false",
                    "description": "if True, noise is added to the simulated visibilities. There are two ways to obtain noise level. It can either be given manually using",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.variance",
                    "name": "Csimulator.noise.variance",
                    "value": "None",
                    "default": "None",
                    "description": "variance in Jy^2 of the Gaussian noise added to visibilities (to every element of the cube, so the noise level should be appropriate for single polarisation, single spectral channel). This parameter is only used if",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.rms",
                    "name": "Csimulator.noise.rms",
                    "value": "None",
                    "default": "None",
                    "description": "rms in Jy of the Gaussian noise added to visibilities (to every element of the cube, so the noise level should be appropriate for single polarisation, single spectral channel). This parameter is only used if",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.Tsys",
                    "name": "Csimulator.noise.Tsys",
                    "value": "None",
                    "default": "None",
                    "description": "Tsys in Kelvins. This parameter should only come in pair with",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.efficiency",
                    "name": "Csimulator.noise.efficiency",
                    "value": "None",
                    "default": "None",
                    "description": "Beam efficiency. This parameter should only come in pair with",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.seed1",
                    "name": "Csimulator.noise.seed1",
                    "value": "time",
                    "default": "time",
                    "description": "First seed of the random generator. Usual substitution rules apply (i.e. it is possible to have rank-dependent seed by specifying \"%w\"). If the word \"time\" is given, the seed will be taken from the timer.",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.noise.seed2",
                    "name": "Csimulator.noise.seed2",
                    "value": "%w",
                    "default": "%w",
                    "description": "Second seed of the random generator. Usual substitution rules apply (i.e. it is possible to have rank-dependent seed by specifying \"%w\"). If the word \"time\" is given, the seed will be taken from the timer.",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.modelReadByMaster",
                    "name": "Csimulator.modelReadByMaster",
                    "value": "true",
                    "default": "true",
                    "description": "This parameter has effect in the parallel case only (can be set to anything in the serial case without affecting the result). If true, the sky model is read by the master and is then distributed to all workers. If false, each worker reads the model, which should be accessible from the worker nodes. This approach cuts down communication when the model is too big. Workers can also use individual models with the help of the substitution mechanism.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.msWrittenByMaster",
                    "name": "Csimulator.msWrittenByMaster",
                    "value": "false",
                    "default": "false",
                    "description": "If true, the workers send data to the master which writes a single measurement set, otherwise each worker writes its own measurement set which name is either given explicitly or via the substitution rule. This option is used to distribute simulation load implicitly, splitting in frequency channels. This is unlike the (default) explicit distribution of work which relies on w wildcard and the substitution rules used appropriately in the parset: if this parameter is false and csimulator is executed in parallel, each non-zero rank beco\\ mes an independent worker which substitutes w in the parset by the worker number, where supported, and, therefore, can simulate different data (e.g. different frequency or differ\\ ent time range). If this option is set to true, master dist\\ ributes the prediction work to all available workers as eve\\ nly as possible (the total number of spectral channels divi\\ ded by the number of available workers, or that plus one if the number of channels doesn't divide evenly, is assigned to each available worker). In this case, care must be taken wi\\ w in the parset. The substitution is honored, but the appr\\ opriate code may be executed on master instead of worker, which would result in w being replaced by -1. In this mode, w should really only be used with the random seed initiali\\ sation, where it is the default (see above), but this is rarely changed by the end user anyway. If the total number of channel doesn't divide evenly between workers, the last worker will process less channels as appropriate. Note, the case where the number of available workers exceeds the numb\\ er of simulated spectral channels is not supported and will cause an exception. With the current ADE system with the number of channels being an integral multiple of 216, it makes sense to run the csimulator with 55, 109 or 217 ranks. The option is allowed to be set to true in the parallel case only.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "sources.definition.sources.names",
                    "name": "sources.definition.sources.names",
                    "value": "None",
                    "default": "None",
                    "description": "or a number of components. The name is used to reference the details on the corresponding sky model given in separate parameters (see below) and can be arbitrary.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [
                        "List of sources (or fields) to simulate. Each field is definded by an image and"
                    ],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.direction",
                    "name": "Csimulator.sources.nameOfSource.direction",
                    "value": "None",
                    "default": "None",
                    "description": "Direction to the source or field (given as direction String, e.g.",
                    "readonly": false,
                    "type": "direction",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.model",
                    "name": "Csimulator.sources.nameOfSource.model",
                    "value": "None",
                    "default": "None",
                    "description": "If this parameter is defined, an image-based model is used for the source. The value of this parameter is the file name of the image. Usual substituting rules apply (see the description at the top of the page). However, the substitution only makes sense if workers read the model (see",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.nterms",
                    "name": "Csimulator.sources.nameOfSource.nterms",
                    "value": "1",
                    "default": "1",
                    "description": "Number of taylor terms in the given image-based model. See the",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.components",
                    "name": "Csimulator.sources.nameOfSource.components",
                    "value": "None",
                    "default": "None",
                    "description": "list of components (names) to simulate for this source (or field). Each component defined by parameters",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.flux.i",
                    "name": "Csimulator.sources.nameOfSource.componentName.flux.i",
                    "value": "None",
                    "default": "None",
                    "description": "Flux density of the component in Jy at ref_freq",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.flux.spectral_index",
                    "name": "Csimulator.sources.nameOfSource.componentName.flux.spectral_index",
                    "value": "0",
                    "default": "0",
                    "description": "Spectral index of the component",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.flux.ref_freq",
                    "name": "Csimulator.sources.nameOfSource.componentName.flux.ref_freq",
                    "value": "None",
                    "default": "None",
                    "description": "Reference frequency of spectrum",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.direction.ra",
                    "name": "Csimulator.sources.nameOfSource.componentName.direction.ra",
                    "value": "None",
                    "default": "None",
                    "description": "RA offset from the field centre for the given component (in radians)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.direction.dec",
                    "name": "Csimulator.sources.nameOfSource.componentName.direction.dec",
                    "value": "None",
                    "default": "None",
                    "description": "Dec offset from the field centre for the given component (in radians)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.shape.bmaj",
                    "name": "Csimulator.sources.nameOfSource.componentName.shape.bmaj",
                    "value": "None",
                    "default": "None",
                    "description": "Required only for a gaussian component. Major axis of the gaussian (in radians) for this component.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.shape.bmin",
                    "name": "Csimulator.sources.nameOfSource.componentName.shape.bmin",
                    "value": "None",
                    "default": "None",
                    "description": "Required only for a gaussian component. Minor axis of the gaussian (in radians) for this component.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.sources.nameOfSource.componentName.shape.bpa",
                    "name": "Csimulator.sources.nameOfSource.componentName.shape.bpa",
                    "value": "None",
                    "default": "None",
                    "description": "Required only for a gaussian component. Position angle of the gaussian (in radians) for this component.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.telescope",
                    "name": "antennas.definition.antennas.telescope",
                    "value": "None",
                    "default": "None",
                    "description": "name of the array, e.g. ASKAP. This name is used to compose other parameter names (see below)",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.names",
                    "name": "antennas.definition.antennas.nameOfArray.names",
                    "value": "None",
                    "default": "None",
                    "description": "List of antenna names included into array, e.g. ANT1, ANT2, etc. These names are used to form the parameter name to define the position of each antenna (in the form",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.mount",
                    "name": "antennas.definition.antennas.nameOfArray.mount",
                    "value": "equatorial",
                    "default": "equatorial",
                    "description": "Antenna mount (must be the same for the whole array). Only",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.diameter",
                    "name": "antennas.definition.antennas.nameOfArray.diameter",
                    "value": "12m",
                    "default": "12m",
                    "description": "Diameter of the antennas (assumed the same for the whole array)",
                    "readonly": false,
                    "type": "quantity",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.coordinates",
                    "name": "antennas.definition.antennas.nameOfArray.coordinates",
                    "value": "local",
                    "default": "local",
                    "description": "Type of the coordinate system used to define antenna position. Allowed values are",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.scale",
                    "name": "antennas.definition.antennas.nameOfArray.scale",
                    "value": "1.0",
                    "default": "1.0",
                    "description": "Optional scaling factor for the antenna layout. Default is no scaling.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.antennaName",
                    "name": "antennas.definition.antennas.nameOfArray.antennaName",
                    "value": "None",
                    "default": "None",
                    "description": "Coordinates (in the form [x,y,z], the values are in metres) for antenna with name antennaName. There should be one such parameter for each antenna listed in",
                    "readonly": false,
                    "type": "vector<Float>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "antennas.definition.antennas.nameOfArray.location",
                    "name": "antennas.definition.antennas.nameOfArray.location",
                    "value": "None",
                    "default": "None",
                    "description": "Centre location for the array layout given as a 4-element vector with longitude, latitude, altitude (all given as quantities) and reference frame, i.e.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.feeds.names",
                    "name": "Csimulator.feeds.names",
                    "value": "None",
                    "default": "None",
                    "description": "List of beams to define (e.g. [Beam1,Beam2]), at least one should be defined. The names are used to compose the parameter name (in the form",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.feeds.mode",
                    "name": "Csimulator.feeds.mode",
                    "value": "perfect",
                    "default": "perfect",
                    "description": "Polarisation properties of each beam (assumed the same for all). Any String understood by casacore is supported. Default is perfect (i.e. not sensitive to circular or orthogonal linear polarisation) linears. Note, that although \"perfect L R\" is supported here, in some other places the linear receptors are implicitly assumed.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.feeds.beamName",
                    "name": "Csimulator.feeds.beamName",
                    "value": "None",
                    "default": "None",
                    "description": "Dimensionless offset of the given beam from the boresight direction (given as [x,y]). Values are multiplied by",
                    "readonly": false,
                    "type": "vector<Float>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.feeds.spacing",
                    "name": "Csimulator.feeds.spacing",
                    "value": "None",
                    "default": "None",
                    "description": "Optional parameter. If present, it determines the dimension and scaling of the beam layout (see above). If not defined, all beam offsets are assumed to be in radians.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.spws.names",
                    "name": "Csimulator.spws.names",
                    "value": "None",
                    "default": "None",
                    "description": "List of names for all spectral windows. Names are used to define parameters for each spectral window (in the form",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.spws.nameOfWindow",
                    "name": "Csimulator.spws.nameOfWindow",
                    "value": "None",
                    "default": "None",
                    "description": "A 4-element vector describing the actual spectral window (or correlator setup) configuration containing the number of channels, frequency of the first channel (quantity), frequency increment (quantity) and polarisation products required (given as",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.blockage",
                    "name": "Csimulator.simulation.blockage",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "Fractional blocakge limit to determine whether antenna is shadowed. It is passed directly to casacore's NewMSSimulator which generates the actual metadata. If the antenna aperture area larger than this fraction from the total area is shadowed, all visibilities including this antenna are flagged. (",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.elevationlimit",
                    "name": "Csimulator.simulation.elevationlimit",
                    "value": "8deg",
                    "default": "8deg",
                    "description": "Elevation limit of all antennas. If source elevation is below this value, corresponding visibilities are flagged. Note, casacore's NewSimulator calculates the source elevation for the reference location only. Therefore, even if the array is sparse enough all baselines will be flagged at the same time.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.autocorrwt",
                    "name": "Csimulator.simulation.autocorrwt",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "Relative weight given to autocorrelations (default value of 0.0 means the weight will be 0). Csimulator assumes the same diameter for all antennas. In this case, an equal weight of 1 will be generated for all visibilities. Auto-correlations will be assigned a weight equal to this factor. (",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.integrationtime",
                    "name": "Csimulator.simulation.integrationtime",
                    "value": "10s",
                    "default": "10s",
                    "description": "Simulated integration time of the correlator.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.usehourangles",
                    "name": "Csimulator.simulation.usehourangles",
                    "value": "True",
                    "default": "True",
                    "description": "if True, the start and stop time are interpreted as hour angles, rather than actual UT times",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.simulation.referencetime",
                    "name": "Csimulator.simulation.referencetime",
                    "value": "None",
                    "default": "None",
                    "description": "Reference epoch used to specify start and stop time, e.g. [2007Mar07, UTC]",
                    "readonly": false,
                    "type": "epoch String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.observe.number",
                    "name": "Csimulator.observe.number",
                    "value": "0",
                    "default": "0",
                    "description": "Number of scans to simulate (should be non-zero, default value would cause an exception). Parameters describing each scan are given by",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Csimulator.observe.scanN",
                    "name": "Csimulator.observe.scanN",
                    "value": "None",
                    "default": "None",
                    "description": "Parameters for the scan N (0..number-1) specified as a 4-element vector (e.g. [10uJy, Wide0, -0.0416667h, 0.0416667h]). Usual substitute rules apply for the first two elements of the vector. The first element is the source name (see definition of sources or fields), the second is the spectral window name (see definition of spectral windows). The last two elements are treated as quantities and represent start and stop time (or hour angle if",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.headers",
                    "name": "ImageToFITS.headers",
                    "value": "[]",
                    "default": "[]",
                    "description": "Vector of Strings, being metadata header names to add to the image. Each header name is then specified as its own parameter to provide the value.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.headers.*headerName*",
                    "name": "ImageToFITS.headers.*headerName*",
                    "value": "*None*",
                    "default": "*None*",
                    "description": "Value for the metadata header",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.history",
                    "name": "ImageToFITS.history",
                    "value": "[]",
                    "default": "[]",
                    "description": "Vector of Strings to be recorded in the image metadata as HISTORY statements. Each String gets its own HEADER line.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.casaimage",
                    "name": "ImageToFITS.casaimage",
                    "value": "*None*",
                    "default": "*None*",
                    "description": "The input CASA-format image.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.fitsimage",
                    "name": "ImageToFITS.fitsimage",
                    "value": "*None*",
                    "default": "*None*",
                    "description": "The output FITS-format image.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.memoryInMB",
                    "name": "ImageToFITS.memoryInMB",
                    "value": "64",
                    "default": "64",
                    "description": "Setting this to zero will result in row-by-row copying, otherwise it will attempt to copy with as large a chunk-size as possible, while fitting in the desired memory.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.preferVelocity",
                    "name": "ImageToFITS.preferVelocity",
                    "value": "false",
                    "default": "false",
                    "description": "Write a velocity primary spectral axis if possible.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.opticalVelocity",
                    "name": "ImageToFITS.opticalVelocity",
                    "value": "true",
                    "default": "true",
                    "description": "If writing a velocity, use the optical definition (otherwise use radio).",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.bitpix",
                    "name": "ImageToFITS.bitpix",
                    "value": "-32",
                    "default": "-32",
                    "description": "*bitpix* can presently be set to -32 or 16 only. When",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.minpix",
                    "name": "ImageToFITS.minpix",
                    "value": "1.0",
                    "default": "1.0",
                    "description": "Minimum pixel value for scaling in",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.maxpix",
                    "name": "ImageToFITS.maxpix",
                    "value": "-1.0",
                    "default": "-1.0",
                    "description": "Minimum pixel value for scaling in",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.allowOverwrite",
                    "name": "ImageToFITS.allowOverwrite",
                    "value": "false",
                    "default": "false",
                    "description": "If true, allow",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.degenerateLast",
                    "name": "ImageToFITS.degenerateLast",
                    "value": "false",
                    "default": "false",
                    "description": "If true, axes of length 1 will be written last to the header.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.stokesLast",
                    "name": "ImageToFITS.stokesLast",
                    "value": "false",
                    "default": "false",
                    "description": "Put the Stokes axis last in the FITS file.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.verbose",
                    "name": "ImageToFITS.verbose",
                    "value": "true",
                    "default": "true",
                    "description": "More log messages.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.preferWavelength",
                    "name": "ImageToFITS.preferWavelength",
                    "value": "false",
                    "default": "false",
                    "description": "If true, write a wavelength primary axis.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.airWavelength",
                    "name": "ImageToFITS.airWavelength",
                    "value": "false",
                    "default": "false",
                    "description": "If true and",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "ImageToFITS.copyHistory",
                    "name": "ImageToFITS.copyHistory",
                    "value": "true",
                    "default": "true",
                    "description": "Whether to copy the CASA image's history",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.inputfitscube",
                    "name": "imcontsub.inputfitscube",
                    "value": "None",
                    "default": "None",
                    "description": "Image cube to work with. The input file has to be in FITS format. It is read and left unchanged.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.outputfitscube",
                    "name": "imcontsub.outputfitscube",
                    "value": "generated",
                    "default": "generated",
                    "description": "The name of the cube to write the results to. If the file already exists, it will be overwritten. If the output name is left unspecified, it is generated from the input name: mycube.fits -> mycube.contsub.fits",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.order",
                    "name": "imcontsub.order",
                    "value": "2",
                    "default": "2",
                    "description": "The order of the polynomial used to fit for the continuum.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.threshold",
                    "name": "imcontsub.threshold",
                    "value": "2.0",
                    "default": "2.0",
                    "description": "The threshold (in robust rms units) used to decide which channels to include in the fit for the continuum. A channel is included if it is not flagged and: abs(pixval-median) < threshold*rms where rms is estimated from the IQR (inter quartile range)",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.blocksize",
                    "name": "imcontsub.blocksize",
                    "value": "0",
                    "default": "0",
                    "description": "Do the subtraction in blocks of channels, this serves two needs: match the beamforming interval to deal with discontinuities at boundaries; better model the continuum by fitting over a smaller frequency range. The default of 0 will fit and subtract the whole spectrum at once",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.shift",
                    "name": "imcontsub.shift",
                    "value": "0",
                    "default": "0",
                    "description": "Shift the origin of the subtraction blocks 'left' by this many channels to match the location of beamforming steps.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "imcontsub.interleave",
                    "name": "imcontsub.interleave",
                    "value": "false",
                    "default": "false",
                    "description": "subtract blocks, using blocksize channels to fit the spectrum, but subtracting only the central 50%, stepping by half a block. This avoids some edge effects of the fitting process obvious in the rms spectrum",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [
                        "Interleave the fit"
                    ],
                    "positional": false
                },
                {
                    "text": "Makecube.outputCube",
                    "name": "Makecube.outputCube",
                    "value": "",
                    "default": "",
                    "description": "Name of the spectral cube to be created.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Makecube.inputNamePattern",
                    "name": "Makecube.inputNamePattern",
                    "value": "",
                    "default": "",
                    "description": "The pattern describing the input names. See text for details.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Makecube.restFrequency",
                    "name": "Makecube.restFrequency",
                    "value": "-1.0",
                    "default": "-1.0",
                    "description": "The rest frequency to be written to the cube's coordinate system. Negative values mean nothing is written. Provide either a numerical value or the String \"HI\" (which is equivalent to 1420405751.786).",
                    "readonly": false,
                    "type": "String or",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Makecube.beamReference",
                    "name": "Makecube.beamReference",
                    "value": "mid",
                    "default": "mid",
                    "description": "Which of the input images to get the beam information from. Options include: 'mid' (middle image of list), 'first', 'last', or a number indicating the image (list is zero-based).",
                    "readonly": false,
                    "type": "String or int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "Makecube.beamLog",
                    "name": "Makecube.beamLog",
                    "value": "",
                    "default": "",
                    "description": "Name of the ascii text file to which the beam information for every input file is written.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver",
                    "name": "solver",
                    "value": "none",
                    "default": "none",
                    "description": "Selection of solver. Specify either \"Clean\" or \"Dirty\"",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "verbose",
                    "name": "verbose",
                    "value": "true",
                    "default": "true",
                    "description": "True enables lots of output",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "tolerance",
                    "name": "tolerance",
                    "value": "0.1",
                    "default": "0.1",
                    "description": "cutoff value given as a fraction of the largest diagonal element. The linear system describing interferometric measurement is inverted approximately, assuming that the matrix is diagonal, i.e. the right-hand side is divided by the appropriate diagonal element (which is a weight). If diagonal is smaller than this tolerance multiplied by the largest diagonal element, the right-hand side instead is either divided by the largest diagonal element to get the result or the result is set to zero. This is controlled by",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "weightcutoff",
                    "name": "weightcutoff",
                    "value": "truncate",
                    "default": "truncate",
                    "description": "Either \"zero\" or \"truncate\". This parameter controls what actually happens for values below cutoff defined by the",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "weightcutoff.clean",
                    "name": "weightcutoff.clean",
                    "value": "false",
                    "default": "false",
                    "description": "N is realised among these values.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [
                        "This parameter defines whether the values below cutoff are masked out or not. By default",
                        " the are masked out and so S"
                    ],
                    "positional": "n-based clean never finds optima among these values. if this parameter is true, the mask is actually sqrt(tolerance), which corresponds to truncation of the diagonal during normalisation. this potentially allows cleaning to happen, if no peak of the s"
                },
                {
                    "text": "solver.Clean.algorithm",
                    "name": "solver.Clean.algorithm",
                    "value": "MultiScale",
                    "default": "MultiScale",
                    "description": "Valid choices are \"MultiScale\", \"Basisfunction\", \"Hogbom\", \"MultiScaleMFS\" and \"BasisfunctionMFS\". Use \"Hogbom\" for a single scale, non-MFS case. For the Clean solver, the casacore's",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.scales",
                    "name": "solver.Clean.scales",
                    "value": "[0, 3, 10]",
                    "default": "[0, 3, 10]",
                    "description": "Scales to be solved (defined in pixels). Ignored if algorithm=\"Hogbom\"",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.niter",
                    "name": "solver.Clean.niter",
                    "value": "100",
                    "default": "100",
                    "description": "Number of minor cycles",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.gain",
                    "name": "solver.Clean.gain",
                    "value": "0.7",
                    "default": "0.7",
                    "description": "Loop gain. Fraction of the peak subtracted during one minor cycle.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.speedup",
                    "name": "solver.Clean.speedup",
                    "value": "no speed up",
                    "default": "no speed up",
                    "description": "Relevant for \"MultiScale\" and \"MultiScaleMFS\" only. If defined, the value will be passed as a speed up factor to the lattice cleaners doing the minor cycle. According to casacore's manual, this will speed up clean by raising the threshold (could help if the threshold set too low for the given dataset). The physical meaning of the parameter is the number of iterations required to Float the threshold.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.padding",
                    "name": "solver.Clean.padding",
                    "value": "1.0",
                    "default": "1.0",
                    "description": "Optional padding of all images in the solver (minor cycle will be done on an image this factor times larger on both axes, e.g. to alleviate the fact that FFT is used to compute convolutions). Default value means no padding. At this stage this option is understood by",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.logevery",
                    "name": "solver.Clean.logevery",
                    "value": "1",
                    "default": "1",
                    "description": "How frequently to log progress in the minor cycle. Every nth iteration is reported (ie. if",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.saveintermediate",
                    "name": "solver.Clean.saveintermediate",
                    "value": "true",
                    "default": "true",
                    "description": "Save intermediate images (residuals and preconditioned PSF) at the end of each majorcycle.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.psfwidth",
                    "name": "solver.Clean.psfwidth",
                    "value": "0",
                    "default": "0",
                    "description": "Sets the width of the psf patch used in the minor cycle. This decreases memory use and run time by approximately the ratio of pixels in the patch to pixels in the image.",
                    "readonly": false,
                    "type": "int",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.detectdivergence",
                    "name": "solver.Clean.detectdivergence",
                    "value": "false",
                    "default": "false",
                    "description": "Check if the deconvolution is diverging - stop the major cycles if the residuals increase by a factor 2",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.orthogonal",
                    "name": "solver.Clean.orthogonal",
                    "value": "false",
                    "default": "false",
                    "description": "Use orthogonal spatial basisfunctions - this does not appear to be as useful as expected - avoid in normal use",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "solver.Clean.decoupled",
                    "name": "solver.Clean.decoupled",
                    "value": "false",
                    "default": "false",
                    "description": "Use decoupled residuals - this improves convergence for large scales, allows the use of a lower percentage threshold.minorcycle and seems to have few drawbacks",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "do.threshold.minorcycle",
                    "name": "do.threshold.minorcycle",
                    "value": "no threshold",
                    "default": "no threshold",
                    "description": "If defined, the parameter can be either a single String or a vector of 2 or 3 Strings. A number without units, or with a percentage sign, is interpreted as a fractional stopping threshold (with respect to the peak residual). An absolute flux given in Jy or related units is interpreted as an absolute threshold. Either one or both of these thresholds can be given at the same time. Undefined parameter means no minor cycle thresholding is done. A second absolute flux parameter can be used to specify a deep clean threshold. During deep cleaning only pixels already in the model are searched to find new components. Setting the deep clean threshold to 0.5 times the noise level generally leaves very few sidelobes visible.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "do.threshold.majorcycle",
                    "name": "do.threshold.majorcycle",
                    "value": "-1Jy",
                    "default": "-1Jy",
                    "description": "The target peak residual. Use negative value to ensure all requested major cycles are done.",
                    "readonly": false,
                    "type": "String",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "do.threshold.masking",
                    "name": "do.threshold.masking",
                    "value": "-1",
                    "default": "-1",
                    "description": "N is searched at every minor cycle, rather than a flux peak. A positive value reverts the algorithm back to the traditional absolute flux peak-based clean. In this case, the value is the threshold used for masking on the basis of the weight. For example, a value of 0.9 (btw, this is the default in the casacore's",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [
                        "If the value is negative (default)",
                        " a signal-to-noise based cleaning is done. In other words",
                        " a peak of S"
                    ],
                    "positional": false
                },
                {
                    "text": "do.preconditioner.Names",
                    "name": "do.preconditioner.Names",
                    "value": "empty vector",
                    "default": "empty vector",
                    "description": "List of preconditioners to be applied (in the order they are given in the list). Preconditioners are ASKAPsoft equivalents of visibility weighting (i.e. uniform, robust, natural), which do not require multiple passes over the dataset. Preconditioners can be viewed as operators applied to equation matrix before it is solved. Having the normal matrix as close to the diagonal as possible (a diagonal form is actually assumed during the inversion process) makes the inversion more accurate. By default, no transformation to the normal matrix is done. This is equivalent to the natural weighting. The following preconditioners are currently implemented:",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "do.preconditioner.preservecf",
                    "name": "do.preconditioner.preservecf",
                    "value": "false",
                    "default": "false",
                    "description": "Use a modified PSF to generate any preconditioner that is derived from the uv sampling function (e.g.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.Wiener.noisepower",
                    "name": "preconditioner.preconditionerName.Wiener.noisepower",
                    "value": "none",
                    "default": "none",
                    "description": "If the Wiener filter is defined with",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.Wiener.normalise",
                    "name": "preconditioner.preconditionerName.Wiener.normalise",
                    "value": "false",
                    "default": "false",
                    "description": "This is an additional option for a",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.Wiener.robustness",
                    "name": "preconditioner.preconditionerName.Wiener.robustness",
                    "value": "none",
                    "default": "none",
                    "description": "The noise power is derived from the given value of robustness to have roughly the same effect as the analogous parameter in Robust (i.e., -2.0 close to uniform weighting, +2.0 close to natural weighting). Note that the Wiener filter must be specified with either",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.Wiener.taper",
                    "name": "preconditioner.preconditionerName.Wiener.taper",
                    "value": "none",
                    "default": "none",
                    "description": "If defined, the FFT of the uv sampling function used to generate the Wiener filter (effectively the PSF) will be tapered with a Gaussian. The value of the parameter is the FWHM of the taper in image pixels. Restricting the filter size to approximately that of the primary beam size is of particular importance when imaging over fields that are larger than the primary beam. There is little point to tapering if preservecf = true.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.NormWiener.robustness",
                    "name": "preconditioner.preconditionerName.NormWiener.robustness",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "Roughly the same effect as the same parameter in Robust.",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.Robust.robustness",
                    "name": "preconditioner.preconditionerName.Robust.robustness",
                    "value": "0.0",
                    "default": "0.0",
                    "description": "Post-gridding version of robust weighting is applied. It is recommended that",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.GaussianTaper",
                    "name": "preconditioner.preconditionerName.GaussianTaper",
                    "value": "None",
                    "default": "None",
                    "description": "A Gaussian taper is applied to the visibilities. The parameter should be either a single String with the FWHM of a circular gaussian taper, or a vector of three Strings for an elliptical taper: the major and minor axis FWHM and the position angle. String values may contain units, e.g.",
                    "readonly": false,
                    "type": "vector<String>",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.GaussianTaper.isPsfSize",
                    "name": "preconditioner.preconditionerName.GaussianTaper.isPsfSize",
                    "value": "false",
                    "default": "false",
                    "description": "If true, try to make the final fitted PSF the size given. This uses the restore.beam.cutoff parameter for the fit. A warning will appear in the log if the target PSF size was not achieved.",
                    "readonly": false,
                    "type": "Boolean",
                    "precious": false,
                    "options": [],
                    "positional": false
                },
                {
                    "text": "preconditioner.preconditionerName.GaussianTaper.tolerance",
                    "name": "preconditioner.preconditionerName.GaussianTaper.tolerance",
                    "value": "0.005",
                    "default": "0.005",
                    "description": "Specify the fractional tolerance of the fitted beam size when isPsfSize is true, default is 0.5%",
                    "readonly": false,
                    "type": "Float",
                    "precious": false,
                    "options": [],
                    "positional": false
                }
            ],
            "git_url": "https://gitlab-ci-token:mZn4QNTkE8vs5Ebe2PQq@gitlab.com/ska-telescope/ska-sdp-jacal.git",
            "sha": "7b8ec29"
        }
    ],
    "linkDataArray": []
}